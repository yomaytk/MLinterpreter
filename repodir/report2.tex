\documentclass{jreport}

\usepackage[dvipdfmx]{graphicx}
\usepackage{amssymb, amsmath}

\begin{document}
	\begin{center}
		計算機科学実験演習３ \ ソフトウェア \ レポート２	\\
		氏名：吉村仁志	\\
		提出日：７月４日（木）
	\newpage
	\end{center}
	\chapter{ML$^1$インタプリタ}
		\section{Exercise \ 3.2.1}
			この問題はcui.mlのinitial\_envをiv、iii、iiをIntV 4、IntV 3、IntV 2に束縛して拡張すれば良い。
			環境の拡張にはEnvironment.extend関数を使う。
			実行結果は10になる。
		\section{Exercise \ 3.2.2}
			字句解析と構文解析はcui.mlのdeclを求める際に行われる。また、実際に構文解析結果を計算するのは、eval.mlであり、
			cui.mlのeval\_declの部分で計算が始まる。エラーが発生する可能性がある部分はこれらになるので、
			read\_eval\_printのlet decl = 以降をtry-with構文で囲めばエラー発生時の挙動をwith以下で処理できる。
			また、lexer.mll、parser.mly、eval.mlでexception Errorを定義しておき、with以降でそれぞれの
			エラーにマッチさせ、エラーメッセージを出力する。また、再びプロンプトに戻るためにそれぞれのエラーが発生したとき、発生していないとき
			すべての場合でread\_eval\_printを再帰呼び出しする。
		\section{Exercise \ 3.2.3}
			lexerを、\&\&をAAND、｜｜をOORで拡張、binOpをAAND、OORで拡張する。
			apply\_primの拡張だが、AANDの評価結果を(exp1 \&\& exp2)、OORの評価結果を(exp1 ｜｜ exp2)にする。
			ただし、exp1、exp2は左側のオペランド、右側のオペランドに対応する。
			次に、true ｜｜ undef、false \&\& undefの２つについて考える。これらは、左のオペランドを評価したときに、
			右側の評価結果は全体の評価結果に関係ない。この場合、左側の評価を終えたときに右側を評価せずに評価を終了する。
			\&\&、｜｜にのみマッチする構文BExprをparserに追加する。これにマッチした場合、ANDORBinOp of binop * exp * exp が属性になる。
			次にevalでのANDORBinOpの評価について説明する。まず、binopはAANDかOORのいずれかになるようにしている(parserの還元時アクション
			にこの２つしか出てこない)。左のオペランドを評価しargaに束縛する。次に、binopがAANDかつargaがfalseのときfalse、binOpがOORかつ
			argaがtrueのときtrueを返す。そうでないときは、eval\_exp env (BinOp(op, exp1, exp2))を評価結果にする。
		\section{Exercise \ 3.2.4}
			まず全体の方針を説明する。lexerに(*、*)を追加する。規則commentをlexerに追加する。また、(*の字句を読み取ったとき、以降の字句列の読み取りをcommentに
			入るように comment lexbuf を呼び出す。また、(*、*)の数をcntとしてカウントする。前者の場合がインクリメントし、後者の場合はデクリメントする。
			コメントとして成立する場合は、字句列を左からcntの値を計算したときに、常に0以上であり、最終的に0になることである。
			そこで、cntを整数の参照として定義し、0で初期化する。
			具体的に実装の中身について説明する。まず、mainで(*を読み取ったときに!cntをインクリメントし、comment lexbuf を呼び出す。*)に入った場合は、!cntが-1
			になるので、当然エラーになる。規則commentでは、(*を読み取ったときには!cntをインクリメントし、comment lexbufを呼び出す。
			*)を読み取ったときは、!cntをデクリメントする。!cntが0のときはコメントは終わるので、main lexbufを呼び出す。!cntが0より大きいときは、
			まだコメントは続くので、comment lexbuf を呼び出す。!cntが0より小さいときは、エラーになる。
	\chapter{ML$^2$インタプリタ}
		\section{Exercise \ 3.4.1}
			ML$^2$インタプリタの作成だが、拡張する部分はすべてchap03-2.pdfで解説されており、特に説明する部分はない。
		\section{Exercise \ 3.4.2}
			まず構文解析の方針としては、構文解析で let ＜識別子＞ = ＜式＞ の各宣言を再帰的にマッチするようにする。そこで、parserにDecLetExprを追加する。
			実際には、
\begin{equation}
	\begin{split}
		LET \ x=ID \ EQ \ &e1=Expr \ \\ &e2=DecLetExpr \ \{ \ DecDecl \ (x, \ e1, \ e2) \ \}
	\end{split}
\end{equation}
			のようにe2で再帰呼び出しをしている。また、最後にはLetExprにマッチするので、e=LetExpr をDecletExprに追加する。
			DecDecl について説明する。定義はDecDecl of id * exp * programになる。これはまず、id を exp の評価結果で束縛し、e2 の部分は
			DecDecl または Decl になるのでprogram型である。構文解析結果は、
\begin{equation}DecDecl(DecDecl(...Decl()..)\end{equation}のようなネスト構造になる。
			また、eval.mlでの評価について説明する。
			DecDecl は program 型であるので、eval\_declで処理する。DecDecl (id, e1, e2) を評価するとする。まず、e1 を評価し id に束縛し、
			環境をそれで拡張した新たな環境 newenv を作る。その上で eval\_decl e2 newenv として再帰呼出しする。
		\section{Exercise \ 3.4.4}
			まず構文解析の方針としては、Exercise 3.4.2と同じように 
\begin{equation}let \ <識別子> \ = \ <式> \end{equation}
			の各宣言を再帰的に解析するようにする。
			そこで、parserにAndExprを追加する。また、これはプログラムになるのでまず toplevel でマッチするようにする。toplevel に	
\begin{equation} 
	\begin{split}
		LET \ x=&ID \ EQ \ e1=Expr \ AND \ \\ &e2=AndExpr \ SEMISEMI \ \{ \ AndLet \ (x, \ e1, \ e2) \ \} 
	\end{split}
\end{equation}
			を追加する。これにより and 以下の構文の解析に移る。AndLet について説明する。定義は AndLet of id * exp * programになる。
			これは、exp を評価した結果を id に束縛し、e2 は AndLet 、Decl になる。
			AndExpr は、構造は DecLetExpr と全く同じである。
			構文解析結果は、AndLet(AndLet(...Decl()...)のようなネスト構造になる。
			また、IN による式を定義することもできるため、それも実装する。これのための構文規則 LetAndInExpr を追加する。
			まず、構文解析を以下のように３つの部分に分けて考える。
\begin{equation}let \ a \ = \ 1 \ and \ ...	\end{equation}
\begin{equation}b \ = \ 1 \ and \ ... \end{equation}	
% \begin{equation}...\end{equation}
			\begin{center}
				・\\
				・\\
				・\\
			\end{center}
\begin{equation}c \ = \ 1 \ in \ a+b+c \end{equation}
			上から２つの還元時アクションは LetAndInExp、最後のそれは LetEndInExp になる。
			また、... の部分で LetAndInExpr の再帰定義をする。すなわち、(2.5)、(2.6)、(2.7)はそれぞれ下の(2.8)、(2.9)、(2.10)にマッチする。
\begin{equation}
	\begin{split}
		LET \ x=ID \ &EQ \ e1=Expr \ AND \ \\ &e2=LetAndInExpr \ \{ \ LetAndInExp \ (x, \ e1, \ e2) \ \}
	\end{split}
\end{equation}
\begin{equation}
	\begin{split}
	x=ID \ &EQ \ e1=Expr \ AND \ \\ &e2=LetAndInExpr \ \{ \ LetAndInExp \ (x, \ e1, \ e2) \ \}
	\end{split}
\end{equation}
\begin{equation}
	\begin{split}
	x=ID \ &EQ \ e1=Expr \ IN \\ &e2=Expr \ \{ \ LetEndInExp \ (x, \ e1, \ e2) \ \}
	\end{split}
\end{equation}
			構文解析結果は、\begin{equation}LetAndInExp(LetAndInExp(...LetEndInExp()...)\end{equation} のようなネスト構造になる。
			eval.mlについて説明する。
			まず and による並列宣言では、宣言が終わると同時に変数の束縛が一斉に行われる。また、一斉に束縛が行われるため、and による
			同じ名前の変数の束縛はできない。それの実装を説明する。まず、先の事実から AndLet を評価するごとに環境を更新することはできないので、
			グローバル変数としてリストの参照 andletlist (id * exp) list を定義しておき、宣言されるごとにこれに追加するようにする。
			また、最終的に一斉に環境を更新するための関数 andlistadd 、新たに束縛しようとしている変数と同じ名前の変数がすでに宣言されていないかを
			判定する関数 findid を定義しておく。前者は、リストと環境を引数として受け取って、環境をリストで拡張しその環境を返すような関数である。
			後者は、id とリストを受け取って、リストを走査し id と同じ名前の変数があれば true 、
			そうでなければ false を返すような関数である。
			次に AndLet (id, e1, e2) の処理を説明する。まず findid 関数でいま定義しようとしている変数が andletlist に入っていないかを判定し、true のときにエラーを起こす。
			結果が false のもとで、id と e1 の評価結果のタプルを andletlist に追加し、同じ環境のもとで eval\_decl env e2 env2 として eval\_decl を再帰呼び出しする。
			また、最後に評価する Decl (id, e) に対してだが、ここで anslistadd を用いて環境を拡張するように Decl に機能を追加する。
			次に LetAndInExp 、LetEndInExp の評価について説明する。LetAndInExp (id, e1, e2) の評価についてだが、構造としては AndLet の評価方法と全く同じである。
			すなわち、findid で判定し、false のもとで新しい変数を andletlist に追加し、同じ環境のもとで eval\_exp env e2 として eval\_exp を再帰呼び出しする。
			LetEndInExp (id, e1, e2) の評価は、LetAndInExp と比較すると、andlistadd の拡張をせずに、andletlist で環境を拡張するように変更したものとなる。
	\chapter{ML$^3$インタプリタ}
		\section{Exercise 3.4.1}
			chap03-3.pdf で解説されていない部分について解説する。解説されていない機能は FunExp に還元される構文規則である。それを FunExpr とする。
式は、\begin{equation}fun \ x \rightarrow \ x+1 \end{equation} のようになるため、それを素直に構文規則にすれば良く、下のようになる。	
\begin{equation}FUN \ x=ID \ RARROW \ e=Expr \ \{ \ FunExp \ (x, \ e) \ \} \end{equation}
			また、FunExpr は式であるため Expr に e=FunExpr \{ e \} を追加する。
		\section{Exercise 3.4.2}
			まず (+)、( * )、を字句解析する必要があるため、lexer に (+) を FPLUS、 ( * ) を FMULT として追加する。
			次に構文解析を解説する。まず、(+) の単純な計算と、カリー化関数を定義することを考える。この構文規則として FPlusFunExpr を追加する。
			単純な計算の構文は、	
\begin{equation}FPLUS \ e1=AExpr \ e2=AExpr \ \{ \ BinOp \ (Plus, \ e1, \ e2) \ \} \end{equation}
			のように単なる足し算と同じである。次にカリー化関数を考えるが、そのために新しい式として FplmuFunExp of binop * exp * id を定義する。
			引数が１個の場合の構文は、
\begin{equation} FPLUS \ e=AExpr \ \{ \ FplmuFunExp \ (Plus, \ e, \ "\mathchar`-") \ \} \end{equation}
			引数が０個の場合の構文は、
\begin{equation}FPLUS \ \{ \ FplmuFunExp \ (Plus, \ ILit \ 0, \ "\mathchar`- \ \mathchar`-") \ \} \end{equation}			
			のようにすれば良い。(FplmuFunExp の具体的な説明は後述する。)
次に関数適用を考える。関数適用としてAppExpの構文を \begin{equation}e1=AppExpr \ e2=FPlusFunExpr \ \{ \ AppExp \ (e1, \ e2) \ \} \end{equation}などと変更する
			規則がまず考えられるが、これだけでは FPLUS が後続の引数にすぐに適用されてしまい、関数適用の左結合が実現できない。
			そこで AppExp に、左結合を実現できるように次の規則を追加する。	
\begin{equation}
	\begin{split}
		e1=&AppExpr \ FPLUS \ e2=AExpr \ \{ \  AppExp\\ &(AppExp(e1, \ FplmuFunExp \ (Plus, \ ILit \ 0, \ "\mathchar`- \ \mathchar`-")), \ e2) \ \} 
	\end{split}
\end{equation}
			すなわち、FPLUS に引数が後続しているときに還元時アクションで e1 を FPLUS 単体に適用するようにする。
			これにより左結合が実現できる。
			次にeval.mlでの FplmuFunExp の評価について説明する。まず３つめのフィールドの id だが、これは引数の個数で場合分けするための
			セレクタの役割をしている(bool型などにしても問題ない)。
			これは関数になるので、
\begin{equation}fun \ a \ b \rightarrow a+b \end{equation} 
			とおなじ関数を定義したのと同等となるようにすれば良い。
			(3.8)を構文解析すると下のようになる。	
\begin{equation}FunExp(a, \ FunExp(b, \ BinOp(Plus, \ Var \ a, \ Var \ b))) \end{equation}	
			これを eval\_exp で評価すると、
\begin{equation}ProcV(a, \ FunExp(b, \ BinOp(Plus, \ Var \ a, \ Var \ b)), \ env) \end{equation}となるので、
			FplmuFunExp の評価結果をこれと同じ形にすれば良い。そこで、ダミーの仮引数として id 型 "a"、"b" を用いて、引数が０個のとき、
\begin{equation}ProcV(a, \ FunExp(b, \ FplmuBinOp(Plus, \ "a", \ "b")), \ env) \end{equation}
			引数が１個のとき、
\begin{equation}\begin{split}ProcV("b", \ &FplmuBinOp(Plus, \ "a", \ "b"), \ \\ &ref \ (Environment.extend \ \ "a" \ arga \ env))) \end{split}\end{equation}
			とすれば良い。FplmuBinOp についてだが、これは syntax で FplmuBinOp of binop * id * id として定義され、二つの id の名前の変数
			の値を足すような exp である。評価は BinOp とほぼ同じで容易である。また、引数が１個のときは "a" をその引数の評価結果で束縛したもので
			環境を拡張し、引数を一つ受け取って、それと "a" の値を足すような関数を返す。以上により、(+)に関する実装は完了する。
			( * )についても全く同様である。
		\section{Exercise 3.4.5}
			まず lexer に dfun のための予約語 DFUN を追加する。
			次に新しい exp 型 DfunExp、exval型 DProcV を定義する。DfunExp は、parser の FunExpr で dfun にマッチしたときに還元される。すなわち、
\begin{equation}DFUN \ x=ID \ RARROW \ e=Expr \ \{ \ DfunExp \ (x, \ e) \ \}\end{equation}
			次に DfunExp を eval.ml で評価すると、DProcV になる。また、DProcV のフィールドは ProcV と全く同じである。
			実際に関数適用をするときだが、AppExp を eval\_exp で評価するとき、funval を ProcV とマッチするかどうかを判定するが、
			ここで DProcV のマッチも増やし、DProcV の評価を別に行う。
			次に動的束縛の実装を説明する。まず関数宣言時の環境(DProcVから取り出した環境)を newenv 、今現在の環境 newenv2 をそれぞれ実引数の束縛で拡張する。
			動的束縛は新しい変数が優先されるので、両方共で同じ名前として宣言されている変数があるときは、newenv2 のそれを優先するようにする。
			すなわち、try構文を利用してまず newenv2 のもとでbody を評価し、成功したときはそれが求めるべき結果である。
			失敗したときは newenv のもとで body を評価すれば良い。これで動的束縛が実現できる。
		\section{Exercise 3.4.6}
			まず結果としては、２つめの fun が dfun のとき再帰関数として定義され、評価結果は120となり、
			そうでないときは、再帰関数として定義できず評価結果は25になる。
			fact の定義は以下のように２回行われている。
\begin{equation}let \ fact \ = \ fun \ n \ \rightarrow \ n+1\end{equation}
\begin{equation}
	\begin{split}
		let \ fact \ = \ fun \ n \ \rightarrow \ if \ n < 1 \ then \ 1 \ else \ n \ * \ fact(n \ + \ -1)
	\end{split}
\end{equation}
			fact 5 の評価するときを考える。２つめの fun が fun のときには、(3.15)の定義の最後の fact の呼び出しでは、
			静的束縛により、(3.15)が宣言されたときの fact を呼び出すので、(3.14)の fact が利用される。その結果、
			fact (n + -1) の評価結果は n となり、fact 5 の結果は 5 * 5 = 25 となる。
			２つめの fun が dfun のときは、動的束縛により fact 5 の評価をするときの環境の fact を利用するので、(3.15)
			の fact を呼び出すことになり、再帰的に fact が呼び出され、結果は 120 になる。
	\chapter{ML$^4$インタプリタ}
		\section{Exercise 3.5.1}
			chap03-4.pdf で解説されていない部分について説明する。まず rec の字句解析が必要だから、lexer に 予約語 REC を追加する。
			次に構文解析を説明する。まず let rec 宣言の構文解析だが、これはプログラム型であり、toplevel に以下の規則を追加する。
\begin{equation}
	\begin{split}
		LET \ REC \ &x1=ID \ EQ \ FUN \ x2=ID \ RARROW \ \\ &e=Expr \ SEMISEMI \ \{ \ RecDecl \ (x1, \ x2, \ e) \ \}
	\end{split}
\end{equation}
			次に let rec 式の構文解析だが、まず新しい規則 LetRecExpr を追加する。これは素直に下のようにマッチさせれば良い。
\begin{equation}
	\begin{split}
		LET \ R&EC \ x1=ID \ EQ \ FUN \ x2=ID \ RARROW \ \\ &e1=Expr \ IN \ e2=Expr \ \{ \ LetRecExp \ (x1, \ x2, \ e1, \ e2) \ \}
	\end{split}
\end{equation}
			また、e=LetRecExpr を Expr に追加する。以上で構文解析は完了する。
			次に、RecDecl の評価について考える。これは、program 型であるので eval\_decl で評価する。
			また LetRecExp の評価での dummyenv への破壊的代入までは全く同じであり、それで評価は終わりである。
			以上でML$^4$インタプリタの実装は完了する。
		\section{Exercise 3.5.2}
			最初に構文解析について説明する。まず式の構文解析を考える。let and の並列宣言と同じように、and 以下の再帰定義を行う。
			構文を下のように３つに分割する。
\begin{equation}let \ rec \ f \ = \ fun \ n \ \rightarrow \ f \ (n + -1) \ and \ ...\end{equation}
\begin{equation}g \ = \ fun \ n \ \rightarrow \ g \ (n + -1) \ and \ ...\end{equation}
	\begin{center}
		・\\
		・\\
		・\\
	\end{center}
\begin{equation}h \ = \ fun \ n \ \rightarrow \ h \ (n + -1) \ in \ f \ 3 \end{equation}
			これら３つの構文解析を考えるが、そのための新しい規則 RecAndInExpr を追加する。(4.3)、(4.4)、(4.5)はそれぞれ下の
			(4.6)、(4.7)、(4.8)にマッチするようになる。また、... の部分で再帰定義が行われる。
\begin{equation}
	\begin{split}
		LE&T \ REC \ x1=ID \ EQ \ FUN \ x2=ID \ RARROW \ e1=Expr \ \\ &AND \ e2=RecAndInExpr \ \{ \ LetRecExp \ (x1, \ x2, \ e1, \ e2) \ \}
	\end{split}
\end{equation}
\begin{equation}
	\begin{split}
		x1=&ID \ EQ \ FUN \ x2=ID \ RARROW \ e1=Expr \\ \ &AND \ e2=RecAndInExpr \ \{ \ LetRecExp \ (x1, \ x2, \ e1, \ e2) \ \}
	\end{split}
\end{equation}
\begin{equation}
	\begin{split}
		x=ID \ EQ \ e1=Expr \ IN \ e2=Expr \ \{ \ LetEndInExp \ (x, \ e1, \ e2) \ \}
	\end{split}
\end{equation}
			構文解析の結果は、下のようなネスト構造になる。
\begin{equation}LetRecExp(LetRecExp(...(LetEndInExp()...)\end{equation}
			これにより、式の再帰関数の並列宣言が実行できる。
			次に、プログラムの再帰関数の実装を考える。構文解析は、(4.3)、(4.4)、(4.5)のうち、
			(4.5)の in 以下がない場合と同じである。またそれを(4.5)*とする。まず toplevel に(4.3)に相当する構文の規則を追加する。
			以下のようになる。(RecAndLetについては後述する。)
\begin{equation}
	\begin{split}
		LET \ REC \ &x1=ID \ EQ \ FUN \ x2=ID \ \\ &RARROW \ e1=Expr \ AND \ e2=RecAndExpr \ \\ &SEMISEMI \ \{ \ RecAndLet \ (x1, \ x2, \ e1, \ e2) \ \}
	\end{split}
\end{equation}
			ここで、再帰的な規則になっている新しい規則、RecAndExpr が追加されている。これは、上の and 以下から移る規則であり、
			中身は(4.4)、(4.5)*に相当する構文にマッチする。(4.4)、(4.5)*はそれぞれ、下の(4.11)、(4.12)にマッチする。
\begin{equation}
	\begin{split}
		x1=&ID \ EQ \ FUN \ x2=ID \ RARROW \ e1=Expr \ \\ &AND \ e2=RecAndExpr \ \{ \ RecAndLet \ (x1, \ x2, \ e1, \ e2) \ \}
	\end{split}
\end{equation}
\begin{equation}
	\begin{split}
		x1=ID \ EQ \ &FUN \ x2=ID \ \\ &RARROW \ e=Expr \ \{ \ RecDecl \ (x1, \ x2, \ e) \ \}
	\end{split}
\end{equation}
			構文解析の結果は、下のようなネスト構造になる。
\begin{equation}RecAndLet(RecAndLet(...(RecDecl(...))\end{equation}
			これの評価について説明する。RecAndLet の定義は、RecAndLet of id * id * exp * program となる。
			これは、RecDecl に program 型のフィールドを追加したものである。すなわち、ネスト構造による後続の
			プログラム、RecAndLet、RecDecl が入ることになる。これは eval\_decl で評価するが、
			RecDecl の評価での dummyenv への破壊的代入までは全く同じである。その後に、program 型のフィールド
			を eval\_decl で再帰的に呼び出すことで、上のネスト構造を処理できる。
			次に相互再帰関数の定義を考える。まず下のような相互再帰を評価することを考える。(実際には、この式の評価は止まらない
			が簡単のために条件を省いている。)
\begin{equation}
	\begin{split}
		let \ f \ = \ fun \ n \ \rightarrow \ g \ n \ and \ g \ = \ fun \ n \ \rightarrow \ f \ n
	\end{split}
\end{equation}
			まず、現在の実装でこれを宣言後に評価すると、f の評価の際に g が見つからないと怒られる。すなわち、f の宣言時の環境に g 
			が入っていないことが問題である。宣言が終了したときの環境には f、g の両方が入っているので、宣言が終了したときの環境で
			評価を行えば、正しく実装できる。具体的な実装では、今までは ProcV の body を評価するときには env'を利用するが、まず try 構文を利用し、
			env' のもとで、body を評価し、失敗したときは env のもとでもう一度評価する。これにより正しく実装できる。
	\chapter{ML$^5$インタプリタ}
		\section{Exercise 3.6.2}
			まず、字句解析として [、]、;、:: を MDRPAREN、MDLPAREN、SEMI、COROCORO、として lexer に追加する。
			次にリストの表し方として、新しい exval 型 ConsV of exval * exval を追加する。これは、１つめの exval がリストの直前の値を表し、
			２つめが、後続するリストを表す。後続がない場合は、新しい exval 型 NIlV が入る。
			また、空リスト [] は NIlV となる。例を挙げると、[1;2;3] というのは、
\begin{equation}ConsV(1, \ ConsV(2, \ ConsV(3, \ NilV)))\end{equation}
			[[1;2];[];3] というのは
\begin{equation}ConsV(ConsV(1, \ ConsV(2, \ NilV)), \ ConsV(NilV, \ ConsV(3, \ NilV)))\end{equation}
			といったように表現できる。
			次に、構文解析を説明する。まず::によるリストの拡張を説明する。新しい規則 ListCoroExpr を追加し、この規則に以下を追加する。
			(ListExp については後述)
\begin{equation}e1=ListsinExpr \ COROCORO \ e2=ListCoroExpr \ \{ \ ListExp \ (e1, \ e2) \ \}\end{equation}
			これは、::が連続する場合もあるため、COROCORO の後に再帰的に ListCoroExpr を呼び出している。
			次に、ListinExpr であるが、::で拡張できるのは、exp 型単体であるか、要素が一つ以下のリストであるので、ListinExpr には以下
			が含まれる。
\begin{equation}MDRPAREN \ e=AExpr \ MDLPAREN \ \{ \ ListExp(e, \ NIlV) \ \}\end{equation}
\begin{equation}MDRPAREN \ MDLPAREN \ \{ \ NIlV \ \}\end{equation}
\begin{equation}e=AExpr \ \{ \ e \ \}\end{equation}
			(5.4)が一つの要素からなるリストにマッチし、(5.5)が空リストにマッチし、(5.6)がexp型の値にマッチする。これにより、::による
			リストの拡張の構文解析は完了する。次に、リストの構文解析だが、これのために新しい規則 ListExpr を追加する。
			まず、要素が一つ以下の規則は ListsinExpr になっているので、最後に e=ListsinExpr を追加すれば良い。
			要素が二つ以上の場合について考えるが、ListExpr に以下を追加する。
\begin{equation}MDRPAREN \ e1=ListExpr \ SEMI \ e2=ListInExpr \ \{ \ ListExp \ (e1, \ e2) \ \}\end{equation}
			これは、[ e ; の SEMI までをマッチさせ、後続部分は新しい規則 ListInExpr に移るようにしている。そこで、ListInExpr について説明する。
			ListInExpr はリストの SEMI までを再帰的にマッチさせていくような規則になっている。具体的には以下の二つを持つ。
\begin{equation}e1=Expr \ SEMI \ e2=ListInExpr \ \{ \ ListExp \ (e1, \ e2) \ \}\end{equation}
\begin{equation}e=Expr \ MDLPAREN \ \{ \ ListExp \ (e, \ NIlV) \ \}\end{equation}
			(5.8)は、１要素とSEMIにマッチし、後続を ListInExpr の再帰呼び出しに渡し、(5.9)は、リストの最終要素と閉じ中括弧 ] 
			にマッチするようにしている。これでリストの構文解析は完了する。
			次に、ListExp とその評価について説明する。ListExp は ListExp of exp * exp として定義されている。
			１つめの exp が１要素、２つめの exp が後続部分にあたる。eval\_exp で ListExp を評価するが、ListExp(e1, e2)を評価するならば、
			e1 の評価結果を el に束縛し、ConsV (el, (eval\_exp e2 env))をそのまま返すとすれば良い。
    \chapter{その他}
        \section{工夫した点}
			まず、実装にあたって工夫した点としては、構文解析のデバッグのために新しいファイル syntax\_debug.mlを作ったことである。
			これは、構文解析の結果を eval.ml で評価を始まる前に出力するような関数が定義されてある。これにより、
			パーズでの予期しない解析がされている時の発見が容易になったり、構文解析結果を eval.ml でシミュレートしやすくなった。
		\section{感想}
			難しかった点として、ひとつ目は、まずML$^2$インタプリタのExercise3.4.4の and による並列宣言で、
			新しく束縛された変数を環境に一斉に追加するために、別の関数や変数をグローバルで定義したりと、複雑になった部分である。
			グローバル変数を定義などせずに、工夫次第でもっと簡潔に書けるのではと思った。ふたつ目は、ML$^3$インタプリタの
			Exercise3.4.2の中置演算子の関数適用が左結合できていない部分になかなか気づかずに、初めはparserに冗長な規則が
			増えてしまった部分である。ただ最終的に、個人的には割と簡潔になった気がしたので良かった。
			３つめは、ML$^3$インタプリタのExercise3.4.3である。これは取り組んだのにうまく行かなかったものである。
			関数を宣言した時に、body が関数適用の場合にうまくパーズできなかった。
			おそらく構文解析に関する理解ができていない点が原因であるが、未だによくわからない。４つめは、
			構文解析のコンフリクトの発生を止められなかったことである。いまでもコンフリクトが存在し、
			それにより予期せぬ挙動を起こしている部分はほとんどない気はするが(Exercise3.4.3には影響しているかもしれない)、
			出来る限り、似たような構文規則を作らないようにしても少ししか改善しなかった。構文解析についてより勉強が必要だと思った。
\end{document}
